# This makefile is automatically generated, DO NOT EDIT!

<?--

-- Dependency scanner cache global.
if _G.__cache == nil then
	_G.__cache = {}
end

import(traktor)

-- Read configuration from environment.
local os = OS.getInstance():getEnvironment("MAKE_OS")
local dialect = OS.getInstance():getEnvironment("MAKE_DIALECT")
local format = OS.getInstance():getEnvironment("MAKE_FORMAT")
local include = OS.getInstance():getEnvironment("MAKE_INCLUDE")

dofile(format)

local function printWithColor(c, s)
	if os == "windows" then
		output:printLn("\t@echo " .. s)
	elseif os == "osx" then
		output:printLn("\t@printf \"\\e[0;" .. c .. "m" .. s .. "\\e[0m\\n\"")
	elseif os == "linux" then
		output:printLn("\t@printf '\\e[0;" .. c .. "m" .. s .. "\\e[0m\\n'")
	end
end

local function insertLast(t, iv)
	for i, v in ipairs(t) do
		if v == iv then
			table.remove(t, i)
			break
		end
	end
	table.insert(t, iv)
end

local function collectDependencies(solution, project, configuration, outIncludePaths, outLibraries, outLibrariesExternal, outLibraryPaths)
	-- Add include paths.
	local includePaths = configuration:getIncludePaths()
	for i = 0, includePaths:size() - 1 do
		local ip = Path(includePaths:get(i)):getPathName()
		if ip ~= "" then
			insertLast(outIncludePaths, ip)
		end
	end

	-- Add libraries.
	local libraries = configuration:getLibraries()
	for i = 0, libraries:size() - 1 do
		insertLast(outLibrariesExternal, libraries:get(i))
	end

	-- Add library paths.
	local libraryPaths = configuration:getLibraryPaths()
	for i = 0, libraryPaths:size() - 1 do
		local libraryRelPath = fileSystem:getRelativePath(
			Path(libraryPaths:get(i)),
			projectPath
		)
		local lp = ""
		if libraryRelPath ~= nil then
			lp = libraryRelPath:getPathName()
		else
			lp = Path(libraryPaths:get(i)):getPathName()
		end
		if lp ~= "" then
			insertLast(outLibraryPaths, lp)
		end
	end

	-- Recurse with dependencies.
	local dependencies = project:getDependencies()
	for i = 0, dependencies:size() - 1 do
		local dep = dependencies:get(i)
		if isa(dep, ProjectDependency) then
			local localSolution = solution
			local localProject = dep:getProject()
			local localConfig = localProject:getConfiguration(configuration:getName())
			if localProject:getEnable() then
				insertLast(outLibraries, localProject:getName())
				collectDependencies(
					localSolution,
					localProject,
					localConfig,
					outIncludePaths,
					outLibraries,
					outLibrariesExternal,
					outLibraryPaths
				)
			end
		elseif isa(dep, ExternalDependency) then
			local externalSolution = dep:getSolution()
			local externalProject = dep:getProject()
			local externalConfig = externalProject:getConfiguration(configuration:getName())
			if externalProject:getEnable() then
				local externalRelPath = fileSystem:getRelativePath(
					Path(externalSolution:getRootPath() .. "/" .. configuration:getName()),
					projectPath
				)
				if externalRelPath:getPathName() ~= "" then
					insertLast(outLibraryPaths, externalRelPath:getPathName())
				end
				insertLast(outLibraries, externalProject:getName())
				collectDependencies(
					externalSolution,
					externalProject,
					externalConfig,
					outIncludePaths,
					outLibraries,
					outLibrariesExternal,
					outLibraryPaths
				)
			end
		end
	end
end

local function collectFiles(project, projectOrFilter, pred)
	local items = projectOrFilter:getItems()
	for i = 0, items:size() - 1 do
		local item = items:get(i)
		if isa(item, Filter) then
			collectFiles(project, item, pred)
		else
			local files = item:getSystemFiles(project:getSourcePath())
			for i = 0, files:size() - 1 do
				local file = files:get(i)
				if os ~= "windows" then
					file = Path(files:get(i):getPathNameNoVolume())
				end
				pred(file)
			end
		end
	end
end

local function mergeTable(t, s)
	for k, v in pairs(s) do
		t[k] = v
	end
end

local function scanHeaderDependencies(cache, includePaths, file)
	-- Check if already cached.
	local fpn = file:getPathName()
	if cache[fpn] ~= nil then return cache[fpn]	end

	local c = {}
	c.dependencies = {}
	c.missing = {}
	cache[fpn] = c

	-- Scan for dependencies in files.
	local fs = fileSystem:open(file, File.FmRead)
	if fs == nil then return c end

	local sr = StringReader(BufferedStream(fs), AnsiEncoding())
	while true do
		local s = sr:readLine()
		if s == nil then break end
		local p = s:match("#include.*\"(.*)\"") -- or s:match("#include.*<(.*)>")
		if p ~= nil then
			local found = false
			for _, ip in ipairs(includePaths) do
				local ipp = Path(ip .. "/" .. p):normalized()
				if fileSystem:exist(ipp) then
					if c.dependencies[ipp:getPathName()] ~= true then
						c.dependencies[ipp:getPathName()] = true

						local rc = scanHeaderDependencies(cache, includePaths, ipp)
						mergeTable(c.dependencies, rc.dependencies)
						mergeTable(c.missing, rc.missing)
					end
					found = true
					break
				end
			end
			if not found then
				local ipp = Path(file:getPathOnly() .. "/" .. p):normalized()
				if fileSystem:exist(ipp) then
					if c.dependencies[ipp:getPathName()] ~= true then
						c.dependencies[ipp:getPathName()] = true

						local rc = scanHeaderDependencies(cache, includePaths, ipp)
						mergeTable(c.dependencies, rc.dependencies)
						mergeTable(c.missing, rc.missing)
					end
					found = true
				end
			end
			if not found then
				c.missing[p] = true
			end
		end
	end

	fs:close()
	return c
end

------------------------------------------------

if include ~= nil then
	if dialect == "nmake" then
		output:printLn("!INCLUDE " .. include)
	elseif dialect == "make" then
		output:printLn("include " .. include)
	end
	output:printLn("")
end

local configurations = project:getConfigurations()
local sourcePath = Path(project:getSourcePath())

-- Scan configurations.
local includePaths = {}
local libraries = {}
local externalLibraries = {}
local libraryPaths = {}
for i = 0, configurations:size() - 1 do
	includePaths[i] = {}
	libraries[i] = {}
	externalLibraries[i] = {}
	libraryPaths[i] = {}
	collectDependencies(
		solution,
		project,
		configurations:get(i),
		includePaths[i],
		libraries[i],
		externalLibraries[i],
		libraryPaths[i]
	)
end

-- Collect input files.
local sourceFiles = {}
local resourceFiles = {}
local definitionFile = nil

collectFiles(
	project,
	project,
	function(file)
		local ext = file:getExtension()
		if ext == "c" or ext == "cc" or ext == "cpp" or ext == "m" or ext == "mm" or ext == "rc" then
			table.insert(sourceFiles, file)
		elseif ext == "xdi" or ext == "image" or ext == "png" or ext == "lua" or ext == "js" or ext == "css" then
			table.insert(resourceFiles, file)
		elseif ext == "def" then
			definitionFile = file
		end
	end
)

-- Ensure definition file path is relative to project.
if definitionFile ~= nil then
	definitionFile = fileSystem:getRelativePath(definitionFile, projectPath)
	assert (definitionFile ~= nil)
end

------------------------------------------------

-- Include paths.
for i = 0, configurations:size() - 1 do
	local configuration = configurations:get(i)
	output:print(configuration:getName():upper() .. "_INCLUDE=")

	INCLUDE(solution, project, configuration, includePaths[i], libraryPaths[i], output)

	output:printLn("")
end

------------------------------------------------
output:printLn("")

-- Definitions.
for i = 0, configurations:size() - 1 do
	local configuration = configurations:get(i)
	output:print(configuration:getName():upper() .. "_DEFINES=")

	local definitions = configuration:getDefinitions()
	for j = 0, definitions:size() - 1 do
		local definition = definitions:get(j)
		local def0 = string.sub(definition, 1, 1)
		if not (def0 == "'" or def0 == "`") then
			DEFINE(solution, project, configuration, definition, output)
		else
			output:print(definition)
		end
	end

	output:printLn("")
end

------------------------------------------------
output:printLn("")

-- "all" target.
output:printLn(".PHONY: all")
output:print("all :")
for i = 0, configurations:size() - 1 do
	local configuration = configurations:get(i)
	output:print(" " .. configuration:getName())
end
output:printLn("")
output:printLn("\t@echo all")

------------------------------------------------
output:printLn("")

-- "clean" target.
output:printLn(".PHONY: clean")
output:printLn("clean :")
for i = 0, configurations:size() - 1 do
	local configuration = configurations:get(i)
	if os == "linux" or os == "osx" then
		output:printLn("\trm -Rf " .. configuration:getName())
	elseif os == "windows" then
		output:printLn("\tdel /F /Q " .. configuration:getName())
	end
end

------------------------------------------------
output:printLn("")

-- "install" target.
output:printLn(".PHONY: install")
output:printLn("install :")
for i = 0, configurations:size() - 1 do
	local configuration = configurations:get(i)
	local aggregationItems = configuration:getAggregationItems()
	for i = 0, aggregationItems:size() - 1 do
		local aggregationItem = aggregationItems:get(i)
		local sourceFile = aggregationItem:getSourceFile()
		local targetPath = aggregationItem:getTargetPath()

		sourceFile = Path("../" .. configuration:getName()):concat(Path(sourceFile))

		if os == "windows" then
			targetPath = Path(targetPath)
			output:printLn("\txcopy /D /F /R /Y /I \"" .. sourceFile:getPathName() .. "\" \"" .. targetPath:getPathName() .. "\\\"")
		elseif os == "osx" or os == "linux" then
			printWithColor(35, "Copy " .. sourceFile:getPathNameNoVolume() .. " to " .. targetPath)
			output:printLn("\t@mkdir -p \"" .. targetPath .. "/\"")
			output:printLn("\t@-cp -Rf " .. sourceFile:getPathNameNoVolume() .. " \"" .. targetPath .. "/\"")
		end
	end
end

------------------------------------------------
output:printLn("")

-- Link targets.
for i = 0, configurations:size() - 1 do
	local configuration = configurations:get(i)
	local profile = configuration:getTargetProfile()
	local format = configuration:getTargetFormat()

	output:print(configuration:getName() .. "_OBJS=")
	for _, file in ipairs(sourceFiles) do
		local f = fileSystem:getRelativePath(file, sourcePath)
		assert (f ~= nil)
		output:printLn(" \\")
		output:print("\t" .. configuration:getName() .. "/" .. OBJNAME(f))
	end
	output:printLn("")

	output:printLn(configuration:getName() .. " : \\")
	output:printLn("\t$(" .. configuration:getName() .. "_OBJS)")

	printWithColor(35, "Assembling " .. project:getName() .. "...")

	if dialect == "nmake" then
		output:printLn("\t-@mkdir \"../" .. configuration:getName() .. "\" 1>nul 2>&1")
	elseif dialect == "make" then
		if os == "windows" then
			output:printLn("\t-mkdir \"../" .. configuration:getName() .. "\" 1>nul 2>&1")
		else
			output:printLn("\t@mkdir -p ../" .. configuration:getName())
		end
	end

	LINK(solution, project, configuration, libraryPaths[i], libraries[i], externalLibraries[i], definitionFile, output)

	local aggregationItems = configuration:getAggregationItems()
	for i = 0, aggregationItems:size() - 1 do
		local aggregationItem = aggregationItems:get(i)
		local sourceFile = aggregationItem:getSourceFile()
		local targetPath = aggregationItem:getTargetPath()

		sourceFile = Path("../" .. configuration:getName()):concat(Path(sourceFile))
		targetPath = Path(targetPath)

		if os == "windows" then
			output:printLn("\txcopy /D /F /R /Y /I \"" .. sourceFile:getPathName() .. "\" \"" .. targetPath:getPathName() .. "\\\"")
		elseif os == "osx" or os == "linux" then
			printWithColor(35, "Copy " .. sourceFile:getPathNameNoVolume() .. " to " .. targetPath:getPathNameNoVolume())
			output:printLn("\t@mkdir -p \"" .. targetPath:getPathNameNoVolume() .. "/\"")
			output:printLn("\t@cp -Rf " .. sourceFile:getPathNameNoVolume() .. " \"" .. targetPath:getPathNameNoVolume() .. "/\"")
		end
	end

	output:printLn("")
end

------------------------------------------------

-- Resource targets.

for i = 0, configurations:size() - 1 do
	local configuration = configurations:get(i)
	for _, file in ipairs(resourceFiles) do
		local f1 = fileSystem:getRelativePath(file, projectPath)
		assert (f1 ~= nil)

		output:printLn(configuration:getName() .. "/Resources/" .. file:getFileNameNoExtension() .. ".h : \\")
		output:printLn("\t" .. f1:getPathName())

		printWithColor(35, "Converting " .. file:getFileName() .. "...")
		if dialect == "nmake" then
			output:printLn("\t-@mkdir \"$(@D)\" 1>nul 2>&1")
		elseif dialect == "make" then
			if os == "windows" then
				output:printLn("\t-mkdir \"$(@D:\\=)\"")
			else
				output:printLn("\t@mkdir -p $(@D:\\=)")
			end
		end

		if dialect == "nmake" then
			output:printLn("\t@$(BINARY_INCLUDE) $** $@ c_Resource" .. file:getFileNameNoExtension())
		elseif dialect == "make" then
			output:printLn("\t@$(BINARY_INCLUDE) $^ $@ c_Resource" .. file:getFileNameNoExtension())
		end

		output:printLn("")
	end
end

------------------------------------------------

-- Unit targets.
for i = 0, configurations:size() - 1 do
	local configuration = configurations:get(i)
	for _, file in ipairs(sourceFiles) do
		local c = scanHeaderDependencies(_G.__cache, includePaths[i], file)

		local f = fileSystem:getRelativePath(file, sourcePath)
		assert (f ~= nil)

		local f1 = fileSystem:getRelativePath(file, projectPath)
		assert (f1 ~= nil)

		output:printLn(configuration:getName() .. "/" .. OBJNAME(f) .. " : \\")
		output:print("\t" .. f1:getPathName())
		for dep, _ in pairs(c.dependencies) do
			local f2 = fileSystem:getRelativePath(Path(dep), projectPath)
			assert (f2 ~= nil)
			output:printLn(" \\")
			output:print("\t" .. f2:getPathName())
		end

		-- Add resource builds as dependency to all targets to ensure
		-- resources are built first and always.
		for _, file in ipairs(resourceFiles) do
			output:printLn(" \\")
			output:print("\t" .. configuration:getName() .. "/Resources/" .. file:getFileNameNoExtension() .. ".h")
		end		

		output:printLn("")

		printWithColor(35, "Compiling " .. f:getFileName() .. "...")

		if dialect == "nmake" then
			output:printLn("\t-@mkdir \"$(@D)\" 1>nul 2>&1")
		elseif dialect == "make" then
			if os == "windows" then
				output:printLn("\t-mkdir \"$(@D:\\=)\"")
			else
				output:printLn("\t@mkdir -p $(@D:\\=)")
			end
		end

		CC(solution, project, configuration, f1, "$@", output)

		output:printLn("")
	end
end

--?>
