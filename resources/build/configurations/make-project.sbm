# This makefile is automatically generated, DO NOT EDIT!

<?--

-- Dependency scanner cache global.
if _G.__cache == nil then
	_G.__cache = {}
end

import(traktor)

local function split(s, delimiter)
    local result = {}
    for match in (s .. delimiter):gmatch("(.-)" .. delimiter) do
    	if match ~= "" then
        	table.insert(result, match)
        end
    end
    return result
end

local function insertLast(t, iv)
	for i, v in ipairs(t) do
		if v == iv then
			table.remove(t, i)
			break
		end
	end
	table.insert(t, iv)
end

-- Read configuration from environment.
local os = OS.getInstance():getEnvironment("MAKE_OS")
local dialect = OS.getInstance():getEnvironment("MAKE_DIALECT")
local format = OS.getInstance():getEnvironment("MAKE_FORMAT")
local include = OS.getInstance():getEnvironment("MAKE_INCLUDE")
local architectures = split(OS.getInstance():getEnvironment("MAKE_ARCHITECTURES"), ",") -- "armv7,armv7s,arm64,i386,x86_64"

dofile(format)

local function printWithColor(c, s)
	if os == "windows" then
		output:printLn("\t@echo " .. s)
	elseif os == "osx" then
		output:printLn("\t@printf \"\\e[0;" .. c .. "m" .. s .. "\\e[0m\\n\"")
	elseif os == "linux" then
		output:printLn("\t@printf '\\e[0;" .. c .. "m" .. s .. "\\e[0m\\n'")
	end
end

local function collectDependencies(
	solution,
	project,
	configuration,
	outIncludePaths,
	outLibraries,
	outLibrariesExternal,
	outLibraryPaths
)
	-- Add include paths.
	local includePaths = configuration:getIncludePaths()
	for i = 0, includePaths:size() - 1 do
		local ip = Path(includePaths:get(i)):getPathName()
		if ip ~= "" then
			insertLast(outIncludePaths, ip)
		end
	end

	-- Add external libraries, ex precompiled libraries etc.
	local libraries = configuration:getLibraries()
	for i = 0, libraries:size() - 1 do
		insertLast(outLibrariesExternal, libraries:get(i))
	end

	-- Add library paths.
	local libraryPaths = configuration:getLibraryPaths()
	for i = 0, libraryPaths:size() - 1 do
		local libraryRelPath = fileSystem:getRelativePath(
			Path(libraryPaths:get(i)),
			projectPath
		)
		local lp = ""
		if libraryRelPath ~= nil then
			lp = libraryRelPath:getPathName()
		else
			lp = Path(libraryPaths:get(i)):getPathName()
		end
		if lp ~= "" then
			insertLast(outLibraryPaths, lp)
		end
	end

	-- Recurse with dependencies.
	local dependencies = project:getDependencies()
	for i = 0, dependencies:size() - 1 do
		local dep = dependencies:get(i)
		if isa(dep, ProjectDependency) then
			local localSolution = solution
			local localProject = dep:getProject()
			local localConfig = localProject:getConfiguration(configuration:getName())
			if localProject:getEnable() then

				-- Add library.
				insertLast(outLibraries, localProject:getName())

				-- Recurse with child dependencies.
				if localConfig:getTargetFormat() == "StaticLibrary" then
					collectDependencies(
						localSolution,
						localProject,
						localConfig,
						outIncludePaths,
						outLibraries,
						outLibrariesExternal,
						outLibraryPaths
					)
				else

					-- Only add include paths when dealing with shared library dependencies.
					local includePaths = localConfig:getIncludePaths()
					for j = 0, includePaths:size() - 1 do
						local ip = Path(includePaths:get(j)):getPathName()
						if ip ~= "" then
							insertLast(outIncludePaths, ip)
						end
					end

				end
			end
		elseif isa(dep, ExternalDependency) then
			local externalSolution = dep:getSolution()
			local externalProject = dep:getProject()
			local externalConfig = externalProject:getConfiguration(configuration:getName())
			if externalProject:getEnable() then

				-- Add path to library.
				if externalConfig:getConsumerLibraryPath() ~= "" then
					local aggregateOutputPath = Path(externalSolution:getAggregateOutputPath())
					local consumerLibraryPath = Path(externalConfig:getConsumerLibraryPath())

					local consumerRelPath = fileSystem:getRelativePath(
						aggregateOutputPath:concat(consumerLibraryPath),
						projectPath
					)

					if consumerRelPath ~= nil then
						insertLast(outLibraryPaths, consumerRelPath:getPathName())
					end
				else
					local externalRelPath = fileSystem:getRelativePath(
						Path(externalSolution:getRootPath() .. "/" .. configuration:getName()),
						projectPath
					)
					if externalRelPath ~= nil then
						insertLast(outLibraryPaths, externalRelPath:getPathName())
					end
				end

				-- Add library.
				insertLast(outLibraries, externalProject:getName())

				-- Recurse with child dependencies.
				if externalConfig:getTargetFormat() == "StaticLibrary" then
					collectDependencies(
						externalSolution,
						externalProject,
						externalConfig,
						outIncludePaths,
						outLibraries,
						outLibrariesExternal,
						outLibraryPaths
					)
				else

					-- Only add include paths when dealing with shared library dependencies.
					local includePaths = externalConfig:getIncludePaths()
					for j = 0, includePaths:size() - 1 do
						local ip = Path(includePaths:get(j)):getPathName()
						if ip ~= "" then
							insertLast(outIncludePaths, ip)
						end
					end

				end
			end
		end
	end
end

local function collectFiles(project, projectOrFilter, pred)
	local items = projectOrFilter:getItems()
	for i = 0, items:size() - 1 do
		local item = items:get(i)
		if isa(item, Filter) then
			collectFiles(project, item, pred)
		else
			local files = item:getSystemFiles(project:getSourcePath())
			for i = 0, files:size() - 1 do
				local file = files:get(i)
				if os ~= "windows" then
					file = Path(files:get(i):getPathNameNoVolume())
				end
				pred(file)
			end
		end
	end
end

local function mergeTable(t, s)
	for k, v in pairs(s) do
		t[k] = v
	end
end

local function scanHeaderDependencies(cache, includePaths, file)
	-- Check if already cached.
	local fpn = file:getPathName()
	if cache[fpn] ~= nil then return cache[fpn]	end

	local c = {}
	c.dependencies = {}
	c.missing = {}
	cache[fpn] = c

	-- Scan for dependencies in files.
	local fs = fileSystem:open(file, File.FmRead)
	if fs == nil then return c end

	local sr = StringReader(BufferedStream(fs), AnsiEncoding())
	while true do
		local s = sr:readLine()
		if s == nil then break end
		local p = s:match("#include.*\"(.*)\"") -- or s:match("#include.*<(.*)>")
		if p ~= nil then
			local found = false
			for _, ip in ipairs(includePaths) do
				local ipp = Path(ip .. "/" .. p):normalized()
				if fileSystem:exist(ipp) then
					if c.dependencies[ipp:getPathName()] ~= true then
						c.dependencies[ipp:getPathName()] = true

						local rc = scanHeaderDependencies(cache, includePaths, ipp)
						mergeTable(c.dependencies, rc.dependencies)
						mergeTable(c.missing, rc.missing)
					end
					found = true
					break
				end
			end
			if not found then
				local ipp = Path(file:getPathOnly() .. "/" .. p):normalized()
				if fileSystem:exist(ipp) then
					if c.dependencies[ipp:getPathName()] ~= true then
						c.dependencies[ipp:getPathName()] = true

						local rc = scanHeaderDependencies(cache, includePaths, ipp)
						mergeTable(c.dependencies, rc.dependencies)
						mergeTable(c.missing, rc.missing)
					end
					found = true
				end
			end
			if not found then
				c.missing[p] = true
			end
		end
	end

	fs:close()
	return c
end

------------------------------------------------

if include ~= nil then
	if dialect == "nmake" then
		output:printLn("!INCLUDE " .. include)
	elseif dialect == "make" then
		output:printLn("include " .. include)
	end
	output:printLn("")
end

local configurations = project:getConfigurations()
local sourcePath = Path(project:getSourcePath())

-- Scan configurations.
local includePaths = {}
local libraries = {}
local externalLibraries = {}
local libraryPaths = {}
for i = 0, configurations:size() - 1 do
	includePaths[i] = {}
	libraries[i] = {}
	externalLibraries[i] = {}
	libraryPaths[i] = {}
	collectDependencies(
		solution,
		project,
		configurations:get(i),
		includePaths[i],
		libraries[i],
		externalLibraries[i],
		libraryPaths[i]
	)
end

-- Collect input files.
local sourceFiles = {}
local resourceFiles = {}
local definitionFile = nil

collectFiles(
	project,
	project,
	function(file)
		local ext = file:getExtension()
		if ext == "c" or ext == "cc" or ext == "cpp" or ext == "m" or ext == "mm" or ext == "rc" then
			table.insert(sourceFiles, file)
		elseif ext == "xdi" or ext == "image" or ext == "png" or ext == "lua" or ext == "js" or ext == "css" then
			table.insert(resourceFiles, file)
		elseif ext == "def" then
			definitionFile = file
		end
	end
)

-- Ensure definition file path is relative to project.
if definitionFile ~= nil then
	definitionFile = fileSystem:getRelativePath(definitionFile, projectPath)
	assert (definitionFile ~= nil)
end

------------------------------------------------

-- Include paths.
for i = 0, configurations:size() - 1 do
	local configuration = configurations:get(i)
	output:print(configuration:getName():upper() .. "_INCLUDE=")

	INCLUDE(solution, project, configuration, includePaths[i], libraryPaths[i], output)

	output:printLn("")
end

------------------------------------------------
output:printLn("")

-- Definitions.
for i = 0, configurations:size() - 1 do
	local configuration = configurations:get(i)
	output:print(configuration:getName():upper() .. "_DEFINES=")

	local definitions = configuration:getDefinitions()
	for j = 0, definitions:size() - 1 do
		local definition = definitions:get(j)
		local def0 = string.sub(definition, 1, 1)
		if not (def0 == "'" or def0 == "`") then
			DEFINE(solution, project, configuration, definition, output)
		else
			output:print(definition)
		end
	end

	output:printLn("")
end

------------------------------------------------
output:printLn("")

-- "all" target.
output:printLn(".PHONY: all")
output:print("all :")
for i = 0, configurations:size() - 1 do
	local configuration = configurations:get(i)
	output:print(" " .. configuration:getName())
end
output:printLn("")
output:printLn("\t@echo all")

------------------------------------------------
output:printLn("")

-- "clean" target.
output:printLn(".PHONY: clean")
output:printLn("clean :")
for i = 0, configurations:size() - 1 do
	local configuration = configurations:get(i)
	if #architectures > 0 then
		for _, a in ipairs(architectures) do
			if os == "linux" or os == "osx" then
				output:printLn("\trm -Rf " .. configuration:getName() .. "_" .. a)
			elseif os == "windows" then
				output:printLn("\tdel /F /Q " .. configuration:getName() .. "_" .. a)
			end			
		end
	else
		if os == "linux" or os == "osx" then
			output:printLn("\trm -Rf " .. configuration:getName())
		elseif os == "windows" then
			output:printLn("\tdel /F /Q " .. configuration:getName())
		end
	end
end

------------------------------------------------
output:printLn("")

-- "install" target.
output:printLn(".PHONY: install")
output:printLn("install :")
for i = 0, configurations:size() - 1 do
	local configuration = configurations:get(i)
	local aggregationItems = configuration:getAggregationItems()
	for i = 0, aggregationItems:size() - 1 do
		local aggregationItem = aggregationItems:get(i)

		local aggregateOutputPath = Path(solution:getAggregateOutputPath())
		local sourceFile = Path("../" .. configuration:getName()):concat(Path(aggregationItem:getSourceFile()))
		local targetPath = aggregateOutputPath:concat(Path(aggregationItem:getTargetPath()))

		if os == "windows" then
			output:printLn("\txcopy /D /F /R /Y /I \"" .. sourceFile:getPathName() .. "\" \"" .. targetPath:getPathName() .. "\\\"")
		elseif os == "osx" or os == "linux" then
			printWithColor(35, "Copy " .. sourceFile:getPathNameNoVolume() .. " to " .. targetPath:getPathNameNoVolume())
			output:printLn("\t@mkdir -p \"" .. targetPath:getPathNameNoVolume() .. "/\"")
			output:printLn("\t@-cp -Rf " .. sourceFile:getPathNameNoVolume() .. " \"" .. targetPath:getPathNameNoVolume() .. "/\"")
		end
	end
end

------------------------------------------------
if #architectures > 0 then

	------------------------------------------------
	output:printLn("")

	-- Architecture targets.
	for i = 0, configurations:size() - 1 do
		local configuration = configurations:get(i)
		local profile = configuration:getTargetProfile()
		local format = configuration:getTargetFormat()

		local configuration = configurations:get(i)
		output:printLn(".PHONY: " .. configuration:getName())
		output:print(configuration:getName() .. " :")
		for _, a in ipairs(architectures) do
			output:printLn(" \\")
			output:print("\t" .. configuration:getName() .. "_" .. a)
		end
		output:printLn("")

		if dialect == "nmake" then
			output:printLn("\t-mkdir \"../" .. configuration:getName() .. "\" 1>nul 2>&1")
		elseif dialect == "make" then
			if os == "windows" then
				output:printLn("\t-mkdir \"../" .. configuration:getName() .. "\" 1>nul 2>&1")
			else
				output:printLn("\t@mkdir -p ../" .. configuration:getName())
			end
		end

		if format == "StaticLibrary" then
			printWithColor(35, "Merging architectures into " .. configuration:getName() .. "/" .. productName)
			local productName = PRODUCTNAME(solution, project, configuration)
			output:print("\t@$(AR) $(AR_FLAGS_" .. profile:upper() .. "_STATIC) $(AR_FLAG_OUTPUT)../" .. configuration:getName() .. "/" .. productName)
			for _, a in ipairs(architectures) do
				output:print(" ../" ..configuration:getName() .. "_" .. a .. "/" .. productName)
			end
			output:printLn("")
		end

		local aggregationItems = configuration:getAggregationItems()
		for i = 0, aggregationItems:size() - 1 do
			local aggregationItem = aggregationItems:get(i)

			local aggregateOutputPath = Path(solution:getAggregateOutputPath())
			local sourceFile = Path("../" .. configuration:getName()):concat(Path(aggregationItem:getSourceFile()))
			local targetPath = aggregateOutputPath:concat(Path(aggregationItem:getTargetPath()))

			if os == "windows" then
				output:printLn("\txcopy /D /F /R /Y /I \"" .. sourceFile:getPathName() .. "\" \"" .. targetPath:getPathName() .. "\\\"")
			elseif os == "osx" or os == "linux" then
				printWithColor(35, "Copy " .. sourceFile:getPathNameNoVolume() .. " to " .. targetPath:getPathNameNoVolume())
				output:printLn("\t@mkdir -p \"" .. targetPath:getPathNameNoVolume() .. "/\"")
				output:printLn("\t@-cp -Rf " .. sourceFile:getPathNameNoVolume() .. " \"" .. targetPath:getPathNameNoVolume() .. "/\"")
			end
		end

		output:printLn("")
	end

	------------------------------------------------

	-- Link targets.
	for i = 0, configurations:size() - 1 do
		local configuration = configurations:get(i)
		local profile = configuration:getTargetProfile()
		local format = configuration:getTargetFormat()

		for _, a in ipairs(architectures) do
			output:print(configuration:getName() .. "_" .. a .. "_OBJS=")
			for _, file in ipairs(sourceFiles) do
				local f = fileSystem:getRelativePath(file, sourcePath)
				assert (f ~= nil)
				output:printLn(" \\")
				output:print("\t" .. configuration:getName() .. "_" .. a .. "/" .. OBJNAME(f))
			end
			output:printLn("")

			output:printLn(configuration:getName() .. "_" .. a .. " : \\")
			output:printLn("\t$(" .. configuration:getName() .. "_" .. a .. "_OBJS)")

			printWithColor(35, "Assembling " .. project:getName() .. " (" .. a .. ")...")

			if dialect == "nmake" then
				output:printLn("\t-@mkdir \"../" .. configuration:getName() .. "_" .. a .. "\" 1>nul 2>&1")
			elseif dialect == "make" then
				if os == "windows" then
					output:printLn("\t-mkdir \"../" .. configuration:getName() .. "_" .. a .. "\" 1>nul 2>&1")
				else
					output:printLn("\t@mkdir -p ../" .. configuration:getName() .. "_" .. a)
				end
			end

			LINK(
				solution,
				project,
				configuration,
				a,
				sourcePath,
				sourceFiles,
				libraryPaths[i],
				libraries[i],
				externalLibraries[i],
				definitionFile,
				output
			)

			output:printLn("")
		end
	end

else -- No architectures

	------------------------------------------------
	output:printLn("")

	-- Link targets.
	for i = 0, configurations:size() - 1 do
		local configuration = configurations:get(i)
		local profile = configuration:getTargetProfile()
		local format = configuration:getTargetFormat()

		output:print(configuration:getName() .. "_OBJS=")
		for _, file in ipairs(sourceFiles) do
			local f = fileSystem:getRelativePath(file, sourcePath)
			assert (f ~= nil)
			output:printLn(" \\")
			output:print("\t" .. configuration:getName() .. "/" .. OBJNAME(f))
		end
		output:printLn("")

		output:printLn(configuration:getName() .. " : \\")
		output:printLn("\t$(" .. configuration:getName() .. "_OBJS)")

		printWithColor(35, "Assembling " .. project:getName() .. "...")

		if dialect == "nmake" then
			output:printLn("\t-@mkdir \"../" .. configuration:getName() .. "\" 1>nul 2>&1")
		elseif dialect == "make" then
			if os == "windows" then
				output:printLn("\t-mkdir \"../" .. configuration:getName() .. "\" 1>nul 2>&1")
			else
				output:printLn("\t@mkdir -p ../" .. configuration:getName())
			end
		end

		LINK(
			solution,
			project,
			configuration,
			nil,
			sourcePath,
			sourceFiles,
			libraryPaths[i],
			libraries[i],
			externalLibraries[i],
			definitionFile,
			output
		)

		local aggregationItems = configuration:getAggregationItems()
		for i = 0, aggregationItems:size() - 1 do
			local aggregationItem = aggregationItems:get(i)

			local aggregateOutputPath = Path(solution:getAggregateOutputPath())
			local sourceFile = Path("../" .. configuration:getName()):concat(Path(aggregationItem:getSourceFile()))
			local targetPath = aggregateOutputPath:concat(Path(aggregationItem:getTargetPath()))

			if os == "windows" then
				output:printLn("\txcopy /D /F /R /Y /I \"" .. sourceFile:getPathName() .. "\" \"" .. targetPath:getPathName() .. "\\\"")
			elseif os == "osx" or os == "linux" then
				printWithColor(35, "Copy " .. sourceFile:getPathNameNoVolume() .. " to " .. targetPath:getPathNameNoVolume())
				output:printLn("\t@mkdir -p \"" .. targetPath:getPathNameNoVolume() .. "/\"")
				output:printLn("\t@-cp -Rf " .. sourceFile:getPathNameNoVolume() .. " \"" .. targetPath:getPathNameNoVolume() .. "/\"")
			end
		end

		output:printLn("")
	end

end

------------------------------------------------

-- Resource targets.

for i = 0, configurations:size() - 1 do
	local configuration = configurations:get(i)
	for _, file in ipairs(resourceFiles) do
		local f1 = fileSystem:getRelativePath(file, projectPath)
		assert (f1 ~= nil)

		output:printLn(configuration:getName() .. "/Resources/" .. file:getFileNameNoExtension() .. ".h : \\")
		output:printLn("\t" .. f1:getPathName())

		printWithColor(35, "Converting " .. file:getFileName() .. "...")
		if dialect == "nmake" then
			output:printLn("\t-@mkdir \"$(@D)\" 1>nul 2>&1")
		elseif dialect == "make" then
			if os == "windows" then
				output:printLn("\t-mkdir \"$(@D:\\=)\"")
			else
				output:printLn("\t@mkdir -p $(@D:\\=)")
			end
		end

		if dialect == "nmake" then
			output:printLn("\t@$(BINARY_INCLUDE) $** $@ c_Resource" .. file:getFileNameNoExtension())
		elseif dialect == "make" then
			output:printLn("\t@$(BINARY_INCLUDE) $^ $@ c_Resource" .. file:getFileNameNoExtension())
		end

		output:printLn("")
	end
end

------------------------------------------------

-- Unit targets.
for i = 0, configurations:size() - 1 do
	local configuration = configurations:get(i)
	for _, file in ipairs(sourceFiles) do
		local c = scanHeaderDependencies(_G.__cache, includePaths[i], file)

		local f = fileSystem:getRelativePath(file, sourcePath)
		assert (f ~= nil)

		local f1 = fileSystem:getRelativePath(file, projectPath)
		assert (f1 ~= nil)

		if #architectures > 0 then
			for _, a in ipairs(architectures) do

				output:printLn(configuration:getName() .. "_" .. a .. "/" .. OBJNAME(f) .. " : \\")
				output:print("\t" .. f1:getPathName())
				for dep, _ in pairs(c.dependencies) do
					local f2 = fileSystem:getRelativePath(Path(dep), projectPath)
					assert (f2 ~= nil)
					output:printLn(" \\")
					output:print("\t" .. f2:getPathName())
				end

				-- Add resource builds as dependency to all targets to ensure
				-- resources are built first and always.
				for _, file in ipairs(resourceFiles) do
					output:printLn(" \\")
					output:print("\t" .. configuration:getName() .. "/Resources/" .. file:getFileNameNoExtension() .. ".h")
				end		

				output:printLn("")

				printWithColor(35, "Compiling " .. f:getFileName() .. " (" .. a .. ")...")

				if dialect == "nmake" then
					output:printLn("\t-@mkdir \"$(@D)\" 1>nul 2>&1")
				elseif dialect == "make" then
					if os == "windows" then
						output:printLn("\t-mkdir \"$(@D:\\=)\"")
					else
						output:printLn("\t@mkdir -p $(@D:\\=)")
					end
				end

				CC(
					solution,
					project,
					configuration,
					a,
					f1,
					"$@",
					output
				)

				output:printLn("")
			end
		else
			output:printLn(configuration:getName() .. "/" .. OBJNAME(f) .. " : \\")
			output:print("\t" .. f1:getPathName())
			for dep, _ in pairs(c.dependencies) do
				local f2 = fileSystem:getRelativePath(Path(dep), projectPath)
				assert (f2 ~= nil)
				output:printLn(" \\")
				output:print("\t" .. f2:getPathName())
			end

			-- Add resource builds as dependency to all targets to ensure
			-- resources are built first and always.
			for _, file in ipairs(resourceFiles) do
				output:printLn(" \\")
				output:print("\t" .. configuration:getName() .. "/Resources/" .. file:getFileNameNoExtension() .. ".h")
			end		

			output:printLn("")

			printWithColor(35, "Compiling " .. f:getFileName() .. "...")

			if dialect == "nmake" then
				output:printLn("\t-@mkdir \"$(@D)\" 1>nul 2>&1")
			elseif dialect == "make" then
				if os == "windows" then
					output:printLn("\t-mkdir \"$(@D:\\=)\"")
				else
					output:printLn("\t@mkdir -p $(@D:\\=)")
				end
			end

			CC(
				solution,
				project,
				configuration,
				nil,
				f1,
				"$@",
				output
			)

			output:printLn("")
		end
	end
end

--?>
