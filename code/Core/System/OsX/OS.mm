#include <CoreFoundation/CFBundle.h>#include <Foundation/Foundation.h>#include <glob.h>#include <pwd.h>#include <unistd.h>#include <sys/param.h>#include <sys/syslimits.h>#include "Core/Log/Log.h"#include "Core/Misc/String.h"#include "Core/Misc/TString.h"#include "Core/Singleton/SingletonManager.h"#include "Core/System/OS.h"#include "Core/System/OsX/SharedMemoryOsX.h"namespace traktor{OS& OS::getInstance(){	static OS* s_instance = 0;	if (!s_instance)	{		s_instance = new OS();		SingletonManager::getInstance().add(s_instance);	}	return *s_instance;}uint32_t OS::getCPUCoreCount() const{	return 4;}std::wstring OS::getComputerName() const{	char name[MAXHOSTNAMELEN];	if (gethostname(name, sizeof_array(name)) != -1)		return mbstows(name);	return L"Unavailable";}std::wstring OS::getCurrentUser() const{	passwd* pwd = getpwuid(geteuid());	if (!pwd)		return L"Unavailable";	const char* who = pwd->pw_name;	if (!who)		return L"Unavailable";	return mbstows(who);}std::wstring OS::getUserHomePath() const{	char path[] = { "~" };	glob_t globbuf;		if (glob(path, GLOB_TILDE, NULL, &globbuf) == 0)	{		char* ep = globbuf.gl_pathv[0];		return mbstows(ep);	}		return L"";}std::wstring OS::getUserApplicationDataPath() const{	return getUserHomePath();}std::wstring OS::getWritableFolderPath() const{#if TARGET_OS_IPHONE	NSArray* paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);	NSString* documentsDirectory = [paths objectAtIndex: 0];	return mbstows([documentsDirectory UTF8String]);#else	return getUserHomePath();#endif}bool OS::editFile(const Path& file) const{	return false;}bool OS::exploreFile(const Path& file) const{	return false;}OS::envmap_t OS::getEnvironment() const{	return envmap_t();}bool OS::getEnvironment(const std::wstring& name, std::wstring& outValue) const{	CFBundleRef mainBundle = CFBundleGetMainBundle();	if (mainBundle)	{		bool gotValue = false;				if (name == L"BUNDLE_PATH")	// /path-to-bundle/MyApplication.app		{			if (mainBundle)			{				CFURLRef appUrl = CFBundleCopyBundleURL(mainBundle);				if (appUrl)				{					char bundlePath[PATH_MAX];					CFURLGetFileSystemRepresentation(appUrl, TRUE, (uint8_t*)bundlePath, PATH_MAX);					CFRelease(appUrl);									outValue = mbstows(bundlePath);					gotValue = true;				}			}		}				if (gotValue)			return true;		// Try to get value from bundle.		CFStringRef keyStr = CFStringCreateWithCString(kCFAllocatorDefault, wstombs(name).c_str(), kCFStringEncodingMacRoman);		if (keyStr)		{			CFStringRef valueRef = (CFStringRef)CFBundleGetValueForInfoDictionaryKey(mainBundle, keyStr);			if (valueRef)			{				const char* valueStr = CFStringGetCStringPtr(valueRef, kCFStringEncodingMacRoman);				if (valueStr)				{					outValue = mbstows(valueStr);										// \hack Replace "\$" sequences with plain "$" as Info.plist preprocessor					// seems to intercept and remove those.					outValue = replaceAll< std::wstring >(outValue, L"\\$", L"$");										gotValue = true;				}			}			CFRelease(keyStr);		}				if (gotValue)			return true;	}	// Ordinary variables; read from process environment.	const char* env = getenv(wstombs(name).c_str());	if (!env)		return false;			outValue = mbstows(env);	return true;}Ref< IProcess > OS::execute(	const Path& file,	const std::wstring& commandLine,	const Path& workingDirectory,	const envmap_t* envmap,	bool redirect,	bool mute,	bool detach) const{	return 0;}Ref< ISharedMemory > OS::createSharedMemory(const std::wstring& name, uint32_t size) const{	return new SharedMemoryOsX(size);}OS::OS(){}OS::~OS(){}void OS::destroy(){	delete this;}}