<?xml version="1.0" encoding="utf-8"?>
<object type="traktor.render.ShaderModule">
	<text>
	<![CDATA[
// Sky and clouds from shadertoy.com/view/MdGfzh

vec3 getSkyColor(vec3 sunDirection, vec3 sunColor, vec3 rd)
{
    const float sundot = clamp(dot(rd, sunDirection), 0.0f, 1.0f);

	vec3 col = vec3(0.2, 0.5, 0.85) * 1.1 - max(rd.y,0.01) * max(rd.y, 0.01) * 0.5;
    col = mix( col, 0.85 * vec3(0.7, 0.75, 0.85), pow(1.0 - max(rd.y, 0.0), 6.0) );

    col += 0.25 * vec3(1.0,0.7,0.4) * pow( sundot, 5.0 );
    col += 0.25 * vec3(1.0,0.8,0.6) * pow( sundot, 64.0 );
    col += 0.20 * vec3(1.0,0.8,0.6) * pow( sundot, 512.0 );
    
    col += clamp((0.1 - rd.y) * 10.0f, 0.0f, 1.0f) * vec3(0.0f, 0.1f, 0.2f);
    col += sunColor * pow(sundot, 8.0f);

    return col;
}

#define SCENE_SCALE						(10.0f)
#define INV_SCENE_SCALE					(0.1f)

#define CLOUD_MARCH_STEPS 24
#define CLOUD_SELF_SHADOW_STEPS 6

#define EARTH_RADIUS   					(50000.0f)
#define CLOUDS_BOTTOM   					(1050.)
#define CLOUDS_TOP      					(2450.)

#define CLOUDS_COVERAGE					(0.5f)

#define CLOUDS_DETAIL_STRENGTH			(0.2f)
#define CLOUDS_BASE_EDGE_SOFTNESS		(0.15f)
#define CLOUDS_BOTTOM_SOFTNESS			(0.01f)
#define CLOUDS_DENSITY					(0.1f)
#define CLOUDS_SHADOW_MARGE_STEP_SIZE	(6.0f)
#define CLOUDS_SHADOW_MARGE_STEP_MULTIPLY	(1.3f)
#define CLOUDS_FORWARD_SCATTERING_G		(0.8f)
#define CLOUDS_BACKWARD_SCATTERING_G		(-0.4f)
#define CLOUDS_SCATTERING_LERP			(0.4f)

#define CLOUDS_AMBIENT_COLOR_TOP			(vec3(169., 167., 200.)*(1.5/255.))
#define CLOUDS_AMBIENT_COLOR_BOTTOM		(vec3(39., 67., 87.)*(1.5/255.))
#define CLOUDS_MIN_TRANSMITTANCE 		0.1f

#define CLOUDS_BASE_SCALE 				1.3f
#define CLOUDS_DETAIL_SCALE 				0.4f

float hash12( vec2 p )
{
    p  = 50.0*fract( p*0.3183099 );
    return fract( p.x*p.y*(p.x+p.y) );
}

float hash13(vec3 p3)
{
    p3  = fract(p3 * 1031.1031);
    p3 += dot(p3, p3.yzx + 19.19);
    return fract((p3.x + p3.y) * p3.z);
}

vec3 hash33(vec3 p3)
{
	p3 = fract(p3 * vec3(.1031, .1030, .0973));
    p3 += dot(p3, p3.yxz+19.19);
    return fract((p3.xxy + p3.yxx)*p3.zyx);
}

float valueHash(vec3 p3)
{
    p3  = fract(p3 * 0.1031);
    p3 += dot(p3, p3.yzx + 19.19);
    return fract((p3.x + p3.y) * p3.z);
}

float HenyeyGreenstein( float sundotrd, float g)
{
	float gg = g * g;
	return (1. - gg) / pow( 1. + gg - 2. * g * sundotrd, 1.5);
}

float interectCloudSphere( vec3 rd, float r )
{
	float b = EARTH_RADIUS * rd.y;
	float d = b * b + r * r + 2. * EARTH_RADIUS * r;
	return -b + sqrt( d );
}

float linearstep( const float s, const float e, float v )
{
	return clamp( (v-s)*(1./(e-s)), 0., 1. );
}

float linearstep0( const float e, float v )
{
	return min( v*(1./e), 1. );
}

float remap(float v, float s, float e)
{
	return (v - s) / (e - s);
}

float cloudMapBase(vec3 p, float norY, float time, texture2D clouds2D, sampler cloudSampler)
{
	const vec3 uv = (p + vec3(0.0f, 0.0f, time * 80.0f)) * (0.00005f * CLOUDS_BASE_SCALE);
	const vec3 cloud = texture(sampler2D(clouds2D, cloudSampler), uv.xz).rgb;

	float n = norY * norY;
	n *= cloud.b;
	n += pow(1.0f - norY, 16.0f); 
	return remap(cloud.r - n, cloud.g, 1.0f);
}

float cloudMapDetail(vec3 p, texture3D clouds3D, sampler cloudSampler)
{ 
	p = abs(p) * (0.0016 * CLOUDS_BASE_SCALE * CLOUDS_DETAIL_SCALE);
	return texture(sampler3D(clouds3D, cloudSampler), p).r;
}

float cloudGradient( float norY )
{
	return linearstep( 0., .05, norY ) - linearstep( .8, 1.2, norY);
}

float cloudMap(vec3 pos, vec3 rd, float norY, float time, texture2D clouds2D, texture3D clouds3D, sampler cloudSampler)
{
	vec3 ps = pos;

	float m = cloudMapBase(ps, norY, time, clouds2D, cloudSampler);
	m *= cloudGradient(norY);

	float dstrength = smoothstep(1., 0.5, m);

	// erode with detail
	if (dstrength > 0.)
	{
		m -= cloudMapDetail( ps, clouds3D, cloudSampler ) * dstrength * CLOUDS_DETAIL_STRENGTH;
	}

	m = smoothstep(0.0f, CLOUDS_BASE_EDGE_SOFTNESS, m + (CLOUDS_COVERAGE - 1.0f));
	m *= linearstep0(CLOUDS_BOTTOM_SOFTNESS, norY);

	return clamp(m * CLOUDS_DENSITY * (1.0f + max((ps.x - 7000.0f) * 0.005f, 0.0f)), 0.0f, 1.0f);
}

float volumetricShadow(vec3 from, float sundotrd, float time, vec3 sunDirection, texture2D clouds2D, texture3D clouds3D, sampler cloudSampler )
{
    float dd = CLOUDS_SHADOW_MARGE_STEP_SIZE;
    vec3 rd = sunDirection;
    float d = dd * 0.5f;
    float shadow = 1.0;

    for (int s = 0; s < CLOUD_SELF_SHADOW_STEPS; s++)
	{
        vec3 pos = from + rd * d;
        float norY = (length(pos) - (EARTH_RADIUS + CLOUDS_BOTTOM)) * (1.0f / (CLOUDS_TOP - CLOUDS_BOTTOM));

        if (norY > 1.)
			return shadow;

        float muE = cloudMap(pos, rd, norY, time, clouds2D, clouds3D, cloudSampler);
        shadow *= exp(-muE * dd);

        dd *= CLOUDS_SHADOW_MARGE_STEP_MULTIPLY;
        d += dd;
    }

    return shadow;
}

vec4 renderClouds(vec3 ro, vec3 rd, float time, vec3 sunDirection, vec3 sunColor, texture2D clouds2D, texture3D clouds3D, sampler cloudSampler, inout float dist)
{
    if( rd.y < 0. )
        return vec4(0, 0, 0, 1);

    ro.xz *= SCENE_SCALE;
    ro.y = sqrt(EARTH_RADIUS * EARTH_RADIUS - dot(ro.xz,ro.xz));

    float start = interectCloudSphere( rd, CLOUDS_BOTTOM );
    float end  = interectCloudSphere( rd, CLOUDS_TOP );
    
    if (start > dist)
        return vec4(0, 0, 0, 1);
    
    end = min(end, dist);
    
    float sundotrd = dot( rd, -sunDirection);

    float d = start;
    float dD = (end - start) / float(CLOUD_MARCH_STEPS);

    float h =  hash13(rd + fract(time));
    d -= dD * h;

    float scattering = mix(
		HenyeyGreenstein(sundotrd, CLOUDS_FORWARD_SCATTERING_G),
		HenyeyGreenstein(sundotrd, CLOUDS_BACKWARD_SCATTERING_G),
		CLOUDS_SCATTERING_LERP
	);

    float transmittance = 1.0;
    vec3 scatteredLight = vec3(0.0, 0.0, 0.0);

   // dist = EARTH_RADIUS;

    for (int s = 0; s < CLOUD_MARCH_STEPS; s++)
	{
        vec3 p = ro + d * rd;

        float norY = clamp((length(p) - (EARTH_RADIUS + CLOUDS_BOTTOM)) * (1.0f / (CLOUDS_TOP - CLOUDS_BOTTOM)), 0.0f, 1.0f);
        float alpha = cloudMap( p, rd, norY, time, clouds2D, clouds3D, cloudSampler );

        if (alpha > 0.0f)
		{
            dist = min( dist, d);
            vec3 ambientLight = mix( CLOUDS_AMBIENT_COLOR_BOTTOM, CLOUDS_AMBIENT_COLOR_TOP, norY );

            vec3 S = (ambientLight + sunColor * (scattering * volumetricShadow(p, sundotrd, time, sunDirection, clouds2D, clouds3D, cloudSampler))) * alpha;
            float dTrans = exp(-alpha * dD);
            vec3 Sint = (S - S * dTrans) * (1. / alpha);
            scatteredLight += transmittance * Sint; 
            transmittance *= dTrans;
        }

        if (transmittance <= CLOUDS_MIN_TRANSMITTANCE)
			break;

        d += dD;
    }

    return vec4(scatteredLight, transmittance);
}

//
// Noise functions used for cloud shapes
//
float valueNoise( in vec3 x, float tile )
{
    vec3 p = floor(x);
    vec3 f = fract(x);
    f = f * f * (3.0f - 2.0f * f);
	
    return mix(mix(mix( valueHash(mod(p+vec3(0,0,0),tile)), 
                        valueHash(mod(p+vec3(1,0,0),tile)),f.x),
                   mix( valueHash(mod(p+vec3(0,1,0),tile)), 
                        valueHash(mod(p+vec3(1,1,0),tile)),f.x),f.y),
               mix(mix( valueHash(mod(p+vec3(0,0,1),tile)), 
                        valueHash(mod(p+vec3(1,0,1),tile)),f.x),
                   mix( valueHash(mod(p+vec3(0,1,1),tile)), 
                        valueHash(mod(p+vec3(1,1,1),tile)),f.x),f.y),f.z);
}

float voronoi( vec3 x, float tile )
{
    vec3 p = floor(x);
    vec3 f = fract(x);

    float res = 100.;
    for (int k=-1; k<=1; k++)
	{
        for (int j=-1; j<=1; j++)
		{
            for (int i=-1; i<=1; i++)
			{
                vec3 b = vec3(i, j, k);
                vec3 c = p + b;

                if ( tile > 0. ) {
                    c = mod( c, vec3(tile) );
                }

                vec3 r = vec3(b) - f + hash13( c );
                float d = dot(r, r);

                if (d < res) {
                    res = d;
                }
            }
        }
    }

    return 1.-res;
}

float tilableVoronoi( vec3 p, const int octaves, float tile )
{
    float f = 1.;
    float a = 1.;
    float c = 0.;
    float w = 0.;

    if( tile > 0. )
		f = tile;

    for (int i=0; i<octaves; i++ )
	{
        c += a*voronoi( p * f, f );
        f *= 2.0;
        w += a;
        a *= 0.5;
    }

    return c / w;
}

float tilableFbm( vec3 p, const int octaves, float tile )
{
    float f = 1.;
    float a = 1.;
    float c = 0.;
    float w = 0.;

    if( tile > 0. )
		f = tile;

    for( int i=0; i<octaves; i++ )
	{
        c += a * valueNoise( p * f, f );
        f *= 2.0;
        w += a;
        a *= 0.5;
    }

    return c / w;
}

	]]>
	</text>
</object>
