<?xml version="1.0" encoding="utf-8"?>
<object type="traktor.script.Script" version="1">
	<dependencies/>
	<text>
	<![CDATA[
local _camera
local _cameraPosition
local _cameraRotation

local _player
local _playerPosition
local _playerRotation
local _playerDirection

local _gridX
local _gridZ

-- Initialize layer
function layerInit(stage)

	_camera = _self:getEntity("Camera")
	_cameraPosition = _camera:getTransform():translation()
	_cameraRotation = Quaternion(0, 1.2, 0)
	
	_playerPosition = Vector4(
		_cameraPosition:x(),
		0.5,
		_cameraPosition:z()
	)
	_playerRotation = 0
	_playerDirection = Vector4(0, 0, 1, 0)

	-- Get position from existing player.
	if _player ~= nil then
		_playerPosition = _player:getTransform():translation():xyz0()
	end

	_player = _self:createEntity("Player")
	_player:setTransform(Transform(
		_playerPosition,
		Quaternion(0, 0, 0)
	))
	_self:addEntity(_player)
	
	_gridX = 0
	_gridZ = 0
end

-- Update layer
function layerUpdate(stage, info)
	local dT = info:getSimulationDeltaTime()
	local env = stage:getEnvironment()
	local im = env:getInput():getInputMapping()
	
	
	local gridSizeX = 14
	local gridSizeZ = 8
	local gridViewCenterX = _gridX * gridSizeX
	local gridViewCenterZ = _gridZ * gridSizeZ
	local gridViewMinX = gridViewCenterX - gridSizeX / 2
	local gridViewMinZ = gridViewCenterZ - gridSizeZ / 2
	local gridViewMaxX = gridViewCenterX + gridSizeX / 2
	local gridViewMaxZ = gridViewCenterZ + gridSizeZ / 2
	
	
	_cameraPosition = Vector4(
		gridViewCenterX,
		_cameraPosition:y(),
		gridViewCenterZ - 3
	)
	
	
	_camera:setTransform(Transform(
		_cameraPosition,
		_cameraRotation
	))

	local dm = im:getStateValue("STATE_PLAYER_MOVE")
	local dr = im:getStateValue("STATE_PLAYER_ROTATE")

	-- Update player controller.
	local motionVelocity = Vector4(dr * 4, 0, -dm * 4);
	local velocity = _player:getBody():getLinearVelocity()
	_player:getBody():addLinearImpulse(
		Vector4(
			(motionVelocity:x() - velocity:x()) * dT,
			0,
			(motionVelocity:z() - velocity:z()) * dT
		),
		false
	)

	-- Calculate player orientation.
	if velocity:length() > 0.1 then

		_playerDirection = velocity:normalized():mulf(0.1):add(_playerDirection:mulf(0.9))
		_playerRotation = math.atan2(-_playerDirection:z(), _playerDirection:x()) + 3.142/2

--		local rotation = math.atan2(-velocity:z(), velocity:x()) + 3.142/2
--		_playerRotation = _playerRotation * 0.9 + rotation * 0.1
	end

	-- Force angular velocity to be zero; don't want to tip over.
	-- Also ensure orientation is fixed.
	_player:getBody():setAngularVelocity(Vector4(0, 0, 0, 0))
	local bodyTransform = _player:getBody():getTransform()
	_player:getBody():setTransform(Transform(
		bodyTransform:translation(),
		Quaternion(_playerRotation, 0, 0)
	))

	-- Update grid position from player's current position.
	_playerPosition = _player:getTransform():translation()
	if _playerPosition:x() < gridViewMinX then
		_gridX = _gridX - 1
	end
	if _playerPosition:x() > gridViewMaxX then
		_gridX = _gridX + 1
	end
	if _playerPosition:z() < gridViewMinZ then
		_gridZ = _gridZ - 1
	end
	if _playerPosition:z() > gridViewMaxZ then
		_gridZ = _gridZ + 1
	end
end

	]]>
	</text>
</object>
