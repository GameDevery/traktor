<?xml version="1.0" encoding="utf-8"?>
<object type="traktor.script.Script" version="1">
	<dependencies/>
	<text>
	<![CDATA[
local _stepOffset
local _verticalVelocity
local _groundContact
	
--
--
function initializeCharacterController(characterEntity)
	_stepOffset = 0.6
	_verticalVelocity = 0
	_groundContact = false
end

--
--
function step(physicsManager, characterEntity, position, offset, margin, vertical)
	local body = characterEntity:getBody()
	local transform = body:getTransform()

	-- Calculate acting offsets
	local P0 = position
	local P1 = P0:add(offset)
	
	local stepProgress = 1
	while stepProgress > 0 do
	
		-- Trace step offset
		local stepDir = P1:sub(P0)
		local stepDirLength = stepDir:length()
		if stepDirLength > 0 then
			local queryResult = physicsManager:querySweep(
				body,
				transform:rotation(),
				P0,
				stepDir:normalized(),
				stepDirLength,
				-1,
				nil
			)
			if queryResult ~= nil then
			
				local f = queryResult:fraction()
				local N = queryResult:normal()
			
				local Pv = P1:sub(P0)
				local Pc = P0:add(Pv:mulf(f))
				
				local v = P1:sub(Pc)
				local d = v:dot(N)
				local Pe = P1:sub(N:mulf(d))
				
				P0 = Pc:add(N:mulf(margin))
				P1 = Pe:add(N:mulf(margin))
				
				stepProgress = stepProgress - 1 + f
				
				if vertical then
					if _verticalVelocity < 0 then
						_groundContact = true
					end
					_verticalVelocity = 0
				end
			else
				-- No collision
				stepProgress = 0
			end
		else
			-- No motion
			stepProgress = 0
		end
		
	end

	return P1
end


--
--
function stepUp(physicsManager, characterEntity, dT, position)

	-- Positive vertical offset; jumping
	local verticalOffset;
	if _verticalVelocity > 0 then
		verticalOffset = Vector4(0, _verticalVelocity * dT, 0, 0)
	else
		verticalOffset = Vector4(0, 0, 0, 0)
	end

	local fixedOffset = Vector4(0, _stepOffset, 0, 0)
	local offset = verticalOffset:add(fixedOffset)

	return step(physicsManager, characterEntity, position, offset, 0, true)
end

--
--
function stepForward(physicsManager, characterEntity, motion, dT, position)
	return step(physicsManager, characterEntity, position, motion:mulf(dT), 0.02, false)
end

--
--
function stepDown(physicsManager, characterEntity, dT, position)

	-- Negative vertical offset; falling
	local verticalOffset;
	if _verticalVelocity < 0 then
		verticalOffset = Vector4(0, _verticalVelocity * dT, 0, 0)
	else
		verticalOffset = Vector4(0, 0, 0, 0)
	end

	local fixedOffset = Vector4(0, -_stepOffset, 0, 0)
	local offset = verticalOffset:add(fixedOffset)

	_groundContact = false

	return step(physicsManager, characterEntity, position, offset, 0, true)
end

--
-- 
function updateCharacterController(physicsManager, characterEntity, motion, jump, dT)
	local body = characterEntity:getBody()
	local transform = body:getTransform()
	local position = transform:translation()

	-- Apply jump impulse
	if jump and _groundContact then
		_verticalVelocity = 13
	end

	-- Integrate position in three steps.
	position = stepUp(physicsManager, characterEntity, dT, position)
	position = stepForward(physicsManager, characterEntity, motion, dT, position)
	position = stepDown(physicsManager, characterEntity, dT, position)
	
	-- Update vertical velocity due to gravity
	local gravity = -9 * 4
	if not _groundContact then
		_verticalVelocity = _verticalVelocity + gravity * dT
	elseif _verticalVelocity < 0 then
		_verticalVelocity = 0
	end

	body:setTransform(Transform(
		position,
		transform:rotation()
	))
end

	]]>
	</text>
</object>
