<?xml version="1.0" encoding="utf-8"?>
<object type="traktor.script.Script" version="1">
	<dependencies>
		<item>{9580DA89-F78E-EE40-9315-F8F13EF4D019}</item>
	</dependencies>
	<text>
	<![CDATA[
local _replicator
local _ghostPeers
local _ghostProjectiles
local _camera
local _player
local _head
local _pitch
local _lastMotion
local _hitImpulse
local _weaponCharge
local _health
local _kills

-------------------------------------------------------------------------------
function peerListener(replicator, eventId, peerId, eventObject)
	print("Peer listener; event " .. eventId .. "; peer " .. peerId)
	if eventId == 1 then
		print("Creating ghost entity...")
		local ghostEntity = _self:createEntity("Ghost")
		if ghostEntity ~= nil then
			_self:addEntity(ghostEntity)
			replicator:setGhostObject(peerId, ghostEntity)
			table.insert(_ghostPeers, peerId)
		end
	elseif eventId == 2 then
		print("Destroying ghost entity...")
		local ghostEntity = replicator:getGhostObject(peerId)
		if ghostEntity ~= nil then
			_self:removeEntity(ghostEntity)
		end
	elseif eventId == 3 then
		print("Ghost event...")
		eventObject:unpackBegin()
		local et = eventObject:unpackFloat()
		if et == 0 then
			print("...FIRE")
			local Tp = eventObject:unpackTransform()
			table.insert(_ghostProjectiles, { peerId, Tp })
		elseif et == 1 then
			print("...DIED")
			_kills = _kills + 1
		end
	end
end

-------------------------------------------------------------------------------
function determineSpawnPosition(self)
	local spawnEntities = _self:getEntities("Spawn")
	local ghostEntities = _self:getEntities("Ghost")

	-- Loop until we find a position.
	while true do
		local spawnIndex = math.random(0, spawnEntities:length() - 1)
		local spawnPosition = spawnEntities:get(spawnIndex):getTransform():translation()

		-- Check if spawn position is "occupied" by any ghost.
		local occupied = false
		for i = 0, ghostEntities:length() - 1 do
			local ghostPosition = ghostEntities:getTransform():translation()
			local distance = ghostPosition:sub(spawnPosition):length()
			if distance < 4 then
				print "Spawn location occupied; skipping..."
				occupied = true
				break
			end
		end

		if not occupied then
			return spawnPosition
		end
	end
end

-------------------------------------------------------------------------------
function layerInit(stage)

	if false then

		-- Create network peers.
		local peers = LanReplicatorPeers()
		peers:create()

		-- Create network replicator.
		_replicator = Replicator()
		_replicator:create(peers, nil)
		_replicator:addEventType(PropertyState)
		_replicator:addListener(ReplicatorListener(
			Delegate(_self, "peerListener")
		))

	end

	_camera = _self:getEntity("Camera")
	_player = _self:createEntity("Player")
	_head = 0
	_pitch = 0
	_lastMotion = Vector4(0, 0, 0, 0)
	_hitImpulse = Vector4(0, 0, 0, 0)
	_weaponCharge = 0
	_ghostPeers = {}
	_ghostProjectiles = {}
	_health = 100
	_kills = 0
	
	-- fixme: We should start in spawning state...
	local spawnPosition = determineSpawnPosition(self)
	local Tpn = Transform(
		spawnPosition,
		Quaternion(_head, 0, 0)
	)
	_player:setTransform(Tpn)
	_self:addEntity(_player)

	initializeCharacterController(_player)
end

-------------------------------------------------------------------------------
function spawnImpact(position, normal)
	local impact = _self:createEntity("Impact")
	if impact ~= nil then
		impact:setTransform(Transform(
			position,
			Quaternion(Vector4(0, 1, 0), normal)
		))
		_self:addTransientEntity(impact, 2)
	end
end

-------------------------------------------------------------------------------
function layerUpdate(stage, info)
	local physicsManager = stage:getEnvironment():getPhysics():getPhysicsManager()
	local inputMapping = stage:getEnvironment():getInput():getInputMapping()

	local T = info:getSimulationTime()
	local dT = info:getSimulationDeltaTime()
	
	-- Read motion from input.
	local jump = inputMapping:isStatePressed("STATE_PLAYER_JUMP")
	local lookX = inputMapping:getStateValue("STATE_PLAYER_LOOK_X")
	local lookY = inputMapping:getStateValue("STATE_PLAYER_LOOK_Y")
	local move = inputMapping:getStateValue("STATE_PLAYER_MOVE")
	local strafe = inputMapping:getStateValue("STATE_PLAYER_STRAFE")
	local fire = inputMapping:isStateDown("STATE_PLAYER_FIRE")
	
	-- Update looking angles.
	_head = _head + lookX * 0.007
	_pitch = _pitch + lookY * 0.005
	if _pitch < -1 then _pitch = -1 end
	if _pitch > 1 then _pitch = 1 end

	local Tp = _player:getTransform()

	-- Calculate filtered motion.
	local motion = Vector4(strafe, 0, move, 0)
	local motionLn = motion:length()
	if motionLn > 0 then
		motion = motion:normalized():mulf(15)
	end
	local motion = Quaternion(_head, 0, 0):transform(motion)
	motion = motion:mulf(0.2):add(_lastMotion:mulf(0.8))
	motion = motion:add(_hitImpulse)
	_lastMotion = motion
	_hitImpulse = Vector4(0, 0, 0, 0)

	local Tpn = Transform(
		Tp:translation(),
		Quaternion(_head, 0, 0)
	)
	_player:setTransform(Tpn)

	-- Update player character controller.
	updateCharacterController(
		physicsManager,
		_player,
		motion,
		jump,
		dT
	)

	-- Place camera at player head
	local Y = math.sin(T * 2) * 0.1 + math.sin(T * 5) * 0.01 + 0.5
	local Tc = Transform(
		Tp:translation():add(Vector4(0, Y, 0, 0)),
		Quaternion(_head, _pitch, 0)
	)
	_camera:setTransform(Tc)

	-- Launch projectile if firing.
	if fire and _weaponCharge >= 1 then
		_weaponCharge = 0

		-- We've hit something, notify all peers.
		if _replicator ~= nil then
			local state = PropertyState()
			state:packFloat(0)
			state:packTransform(Tc)
			_replicator:broadcastEvent(state)
		end
		
		-- Trace impact location.
		local origin = Tc:translation():xyz1()
		local direction = Tc:transform(Vector4(0, 0, 1, 0))
		local result = physicsManager:queryRay(
			origin,
			direction,
			1000,
			nil
		)
		if result ~= nil then
		
			-- Apply impulse if hitting a dynamic body.
			local body = result:body()
			if body ~= nil and body.addImpulse ~= nil then
				body:setActive(true)
				body:addImpulse(
					result:position(),
					direction:mulf(10),
					false
				)
			end
		
			-- Create impact effect.
			spawnImpact(result:position(), result:normal())
		end
	end

	if _replicator ~= nil then
		-- Update my replicator state.
		local state = PropertyState()
		state:packTransform(Tpn)	
		_replicator:setState(state)

		-- Update replicator.
		_replicator:update(dT)
	end

	-- Update remote peer ghost objects.
	for i,peer in ipairs(_ghostPeers) do
		local ghostState = _replicator:getGhostState(peer)
		local ghostEntity = _replicator:getGhostObject(peer)
		if ghostState ~= nil and ghostEntity ~= nil then
			ghostState:unpackBegin()
			local Tg = ghostState:unpackTransform()
			ghostEntity:setTransform(Tg)
		end
	end
	
	-- Check remote projectiles to see if I'm hit.
	for i,ghostProjectile in ipairs(_ghostProjectiles) do
		local peerId = ghostProjectile[1]
		local projectile = ghostProjectile[2]
		local origin = projectile:translation():xyz1()
		local direction = projectile:transform(Vector4(0, 0, 1, 0))
		local result = physicsManager:queryRay(
			origin,
			direction,
			1000,
			nil
		)
		if result ~= nil then
			if result:body() == _player:getBody() then
				_health = _health - 25
				if _health <= 0 then
					print("Killed by peer " .. peerId)
					local state = PropertyState()
					state:packFloat(1)
					_replicator:sendEvent(peerId, state)
				end
				_hitImpulse = _hitImpulse:add(direction:normalized():mulf(10))
			end

			spawnImpact(result:position(), result:normal())
		end
	end
	_ghostProjectiles = {}
	
	-- Check my vital signs; respawn if necessary.
	if _health <= 0 then
		_health = 100
		local spawnPosition = determineSpawnPosition(self)
		local Tpn = Transform(
			spawnPosition,
			Quaternion(_head, 0, 0)
		)
		_player:setTransform(Tpn)
	end

	-- Update HUD
	local hud = stage:findLayer("HUD")
	if hud ~= nil then
		local moviePlayer = hud:getMoviePlayer()
		if moviePlayer ~= nil then
			moviePlayer:setGlobal("_health", _health)
			moviePlayer:setGlobal("_kills", _kills)
		end
	end
	
	_weaponCharge = _weaponCharge + dT * 5	-- 5 rounds per second
end

	]]>
	</text>
</object>
