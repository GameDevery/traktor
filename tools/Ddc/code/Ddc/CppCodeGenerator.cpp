#include <Core/Io/FileSystem.h>
#include <Core/Io/FileOutputStream.h>
#include <Core/Io/AnsiEncoding.h>
#include <Core/Misc/String.h>
#include <Core/Guid.h>
#include "Ddc/CppCodeGenerator.h"
#include "Ddc/DfnBranch.h"
#include "Ddc/DfnClass.h"
#include "Ddc/DfnMember.h"
#include "Ddc/DfnNamespace.h"
#include "Ddc/DfnType.h"

using namespace traktor;

namespace ddc
{
	namespace
	{

void collectClassNodes(
	const DfnNode* node,
	const DfnNamespace* ns,
	RefArray< const DfnClass >& outClasses,
	std::map< const DfnNode*, const DfnNamespace* >& outNsMap
)
{
	if (const DfnClass* classNode = dynamic_type_cast< const DfnClass* >(node))
	{
		if (ns)
			outNsMap.insert(std::make_pair(classNode, ns));
		outClasses.push_back(classNode);
	}

	if (const DfnNamespace* namespaceNode = dynamic_type_cast< const DfnNamespace* >(node))
	{
		if (ns)
			outNsMap.insert(std::make_pair(namespaceNode, ns));
		collectClassNodes(namespaceNode->getStatements(), namespaceNode, outClasses, outNsMap);
	}

	if (const DfnBranch* branchNode = dynamic_type_cast< const DfnBranch* >(node))
	{
		collectClassNodes(branchNode->getLeft(), ns, outClasses, outNsMap);
		collectClassNodes(branchNode->getRight(), ns, outClasses, outNsMap);
	}
}

void collectClassMembers(
	const DfnNode* node,
	RefArray< const DfnMember >& outMembers
)
{
	if (const DfnMember* memberNode = dynamic_type_cast< const DfnMember* >(node))
	{
		outMembers.push_back(memberNode);
	}

	if (const DfnBranch* branchNode = dynamic_type_cast< const DfnBranch* >(node))
	{
		collectClassMembers(branchNode->getLeft(), outMembers);
		collectClassMembers(branchNode->getRight(), outMembers);
	}
}

	}

T_IMPLEMENT_RTTI_CLASS(L"ddc.CppCodeGenerator", CppCodeGenerator, ICodeGenerator)

bool CppCodeGenerator::generate(const Path& sourceFilePath, const DfnNode* node) const
{
	RefArray< const DfnClass > classes;
	std::map< const DfnNode*, const DfnNamespace* > nsMap;
	collectClassNodes(node, 0, classes, nsMap);

	Path sourcePath = sourceFilePath.getPathNameNoExtension() + L".cpp";
	Path headerPath = sourceFilePath.getPathNameNoExtension() + L".h";

	std::wstring includeGuard = Guid::create().format();
	includeGuard = replaceAll(includeGuard, '{', '_');
	includeGuard = replaceAll(includeGuard, '}', '_');
	includeGuard = replaceAll(includeGuard, '-', '_');
	includeGuard = L"INCLUDE" + includeGuard + L"H";

	Ref< Stream > file = FileSystem::getInstance().open(sourcePath, File::FmWrite);
	FileOutputStream os(file, gc_new< AnsiEncoding >());

	os << L"// THIS FILE IS AUTOMATICALLY GENERATED, DO NOT EDIT!" << Endl;
	os << Endl;
	os << L"#ifndef " << includeGuard << Endl;
	os << L"#define " << includeGuard << Endl;
	os << Endl;

	os << L"#include \"Core/Serialization/Serializable.h\"" << Endl;
	os << Endl;
	
	for (RefArray< const DfnClass >::iterator i = classes.begin(); i != classes.end(); ++i)
	{
		RefArray< const DfnMember > members;
		collectClassMembers((*i)->getMembers(), members);

		std::vector< const DfnNamespace* > ns;
		std::map< const DfnNode*, const DfnNamespace* >::iterator j = nsMap.find(*i);
		while (j != nsMap.end())
		{
			ns.push_back(j->second);
			j = nsMap.find(j->second);
		}
		std::reverse(ns.begin(), ns.end());

		for (std::vector< const DfnNamespace* >::iterator j = ns.begin(); j != ns.end(); ++j)
		{
			os << L"namespace " << (*j)->getName() << Endl;
			os << L"{" << Endl;
		}

		os << Endl;

		os << L"class " << (*i)->getName() << L" : public traktor::Serializable" << Endl;
		os << L"{" << Endl;
		os << L"\tT_RTTI_CLASS(" << (*i)->getName() << L")" << Endl;
		os << Endl;
		os << L"public:" << Endl;

		for (RefArray< const DfnMember >::iterator j = members.begin(); j != members.end(); ++j)
		{
			const DfnType* memberType = checked_type_cast< const DfnType* >((*j)->getMemberType());
			os << L"\tvoid set" << (*j)->getName() << L"(" << memberType->getName() << L" value) const;" << Endl;
			os << Endl;
			os << L"\t" << memberType->getName() << L" get" << (*j)->getName() << L"() const;" << Endl;
			os << Endl;
		}

		os << L"\tvirtual bool serialize(traktor::Serializer& s);" << Endl;
		os << Endl;
		os << L"private:" << Endl;

		for (RefArray< const DfnMember >::iterator j = members.begin(); j != members.end(); ++j)
		{
			const DfnType* memberType = checked_type_cast< const DfnType* >((*j)->getMemberType());
			os << L"\t" << memberType->getName() << L" m_" << (*j)->getName() << L";" << Endl;
		}

		os << L"};" << Endl;

		os << Endl;

		for (std::vector< const DfnNamespace* >::iterator j = ns.begin(); j != ns.end(); ++j)
		{
			os << L"}" << Endl;
		}
	}

	os << Endl;
	os << L"#endif	// " << includeGuard << Endl;

	os.close();

	return true;
}

}
