import(traktor)
import(traktor.drawing)
import(traktor.run)


-- Tools
local tools =
{
	pipeline = "$(DEPLOY_SYSTEM_ROOT)/bin/latest/$(DEPLOY_HOST_OS)/releaseshared/Traktor.Pipeline.App",
	migrate = "$(DEPLOY_SYSTEM_ROOT)/bin/latest/$(DEPLOY_HOST_OS)/releaseshared/Traktor.Database.Migrate.App",
	remote = "$(DEPLOY_SYSTEM_ROOT)/bin/latest/$(DEPLOY_HOST_OS)/releaseshared/Traktor.Remote.Client.App"
}


function string:split(sep)
	local sep, fields = sep or ":", {}
	local pattern = string.format("([^%s]+)", sep)
	self:gsub(pattern, function(c) fields[#fields+1] = c end)
	return fields
end


function string:endswith(send)
	return #self >= #send and self:find(send, #self - #send + 1, true) and true or false
end


function string:trim()
	return self:find'^%s*$' and '' or self:match'^%s*(.*%S)'
end


function string:starts(start)
   return string.sub(self, 1, string.len(start)) == start
end


local function createIcon()
	local iconFile = os:getEnvironment("DEPLOY_PROJECT_ICON")
	if #iconFile <= 0 then
		iconFile = "$(DEPLOY_SYSTEM_ROOT)/resources/runtime/deploy/DefaultIcon.png"
	end

	local iconImage = Image.loadFromFile(iconFile)
	if iconImage == nil then 
		print("Unable to load image " .. iconFile)
		return false
	end

	iconImage:apply(ScaleFilter(256, 256))
	return iconImage:save("Traktor.Amalgam.Game.App.ico")
end


local function generateResponseFile(files)
	local f = fileSystem:open(Path("link.rsp"), 2)
	assert (f ~= nil)

	local s = StreamOutput(f, Utf8Encoding())
	local fna = files:split(" ")
	for _, fn in ipairs(fna) do
		s:printLn(Path(fn):getPathName())
	end

	f:close()
	return "link.rsp"
end


local function linkStaticProduct()
	local debug = (os:getEnvironment("DEPLOY_DEBUG") ~= "")
	local preamble = "\"$(TRAKTOR_HOME)/scripts/vsenv-x86.bat\" && "

	-- Get library paths.
	local libraryPaths = ""
	local paths = ""
	if not debug then paths = os:getEnvironment("DEPLOY_STATIC_PATH_RELEASE"):split("\n") else paths = os:getEnvironment("DEPLOY_STATIC_PATH_DEBUG"):split("\n") end
	for _, p in pairs(paths) do
		libraryPaths = libraryPaths .. "/LIBPATH:\"" .. Path(p):getPathName() .. "\" "
	end

	-- Get files to link or copy.
	local linkFiles = ""
	local files = os:getEnvironment("DEPLOY_STATIC"):split("\n")
	for i = #files, 1, -1 do -- We must link in reverse order to ensure global initializers are executed correctly.
		local f = files[i]
		if f ~= "" then
			if f:endswith(".lib") then
				linkFiles = linkFiles .. f .. " "
			end
		end
	end

	-- Generate symbols which must be included in product after linkage.
	local linkerIncludes = ""
	local modules = os:getEnvironment("DEPLOY_MODULES"):split("\n")
	for _, m in pairs(modules) do
		linkerIncludes = linkerIncludes .. "/INCLUDE:___module__" .. m:gsub("%.", "_") .. " "
	end

	-- Create icon resource.
	if not createIcon()	then
		stderr:printLn("Unable to create product icon.")
		return 1
	end

	-- Generate resource script.
	if run:run("$(TRAKTOR_HOME)/resources/runtime/deploy/win64/Traktor.Amalgam.Game.App.rc.template", "Traktor.Amalgam.Game.App.rc") ~= 0 then
		stderr:printLn("Unable to generate resource script.")
		return 1
	end	

	-- Compile resources.
	local cmd = "rc /fo\"%DEPLOY_EXECUTABLE%.res\" Traktor.Amalgam.Game.App.rc"
	local result = run:execute(preamble .. cmd, nil)
	if result ~= 0 then
		stderr:printLn("Unable to build product resources.")
		stderr:printLn(cmd)
		stderr:printLn(run:stdOut())
		return 1
	end

	-- Generate link response file.
	local rsp = generateResponseFile(linkFiles)

	-- Link files into an executable product.
	local cmd = 
		"link @" .. rsp .. " " .. linkerIncludes .. " " ..
		"%DEPLOY_EXECUTABLE%.res " ..
		"/OUT:%DEPLOY_EXECUTABLE%.exe " ..
		"/PDB:%DEPLOY_EXECUTABLE%.pdb " ..
		libraryPaths ..
		"/MACHINE:X86 " ..
		"/SUBSYSTEM:WINDOWS"
	if not debug then
		cmd = cmd .. " /LTCG /OPT:REF"
	else
		cmd = cmd .. " /DEBUG"
	end
	local result = run:execute(preamble .. cmd, nil)
	if result ~= 0 then
		stderr:printLn("Unable to build executable product.")
		stderr:printLn(cmd)
		stderr:printLn(run:stdOut())
		return 1
	end

	-- Embed manifest in executable product.
	local cmd = "mt -manifest $(TRAKTOR_HOME)/resources/runtime/deploy/win32/manifest.xml -outputresource:$(DEPLOY_EXECUTABLE).exe;1"
	local result = run:execute(preamble .. cmd, nil)
	if result ~= 0 then
		stderr:printLn("Unable to embed manifest into executable product.")
		stderr:printLn(cmd)
		stderr:printLn(run:stdOut())
		return 1
	end

	-- Clean some unwanted files.
	run:rm("*.exp")
	run:rm("*.lib")
	run:rm("*.res")
	run:rm("*.rc")
	run:rm("*.ico")
	run:rm(rsp)
	return 0	
end


-------------------------------------------------------------------------------


function build(args)
	stdout:printLn("Building asset(s)...")
	local cmdline = tools.pipeline .. " -p -s=Pipeline"
	for i = 1, args:size() - 1 do
		cmdline = cmdline .. " " .. args:get(i)
	end
	return run:execute(cmdline)
end


local function deployStatic(args)
	-- Link our product.
	local r = linkStaticProduct()
	if r ~= 0 then return r end

	-- Deploy executable into remote folder.
	run:execute(tools.remote .. " deploy $(DEPLOY_TARGET_HOST) -t=\"$(DEPLOY_PROJECT_NAME)\" $(DEPLOY_EXECUTABLE).exe", nil)
	if run:exitCode() ~= 0 then return run:exitCode() end

	-- Get shared paths.
	local paths = nil
	if not debug then paths = os:getEnvironment("DEPLOY_STATIC_PATH_RELEASE"):split("\n") else paths = os:getEnvironment("DEPLOY_STATIC_PATH_DEBUG"):split("\n") end

	-- Find files to deploy; qualitfy through paths.
	local files = os:getEnvironment("DEPLOY_STATIC"):split("\n")
	for _, p in ipairs(paths) do
		for _, f in ipairs(files) do
			if f ~= "" and not f:endswith(".lib") then
				local qf = Path(p):concat(Path(f))
				if FileSystem.getInstance():exist(qf) then
					run:pushd(p)
					run:execute(tools.remote .. " deploy $(DEPLOY_TARGET_HOST) -t=\"$(DEPLOY_PROJECT_NAME)\" " .. f, nil)
					run:popd()
				end
			end
		end
	end

	return 0
end


local function deployShared(args)
	local debug = (os:getEnvironment("DEPLOY_DEBUG") ~= "")

	-- Create icon resource.
	if not createIcon()	then
		stderr:printLn("Unable to create product icon.")
		return 1
	end

	-- Get shared paths.
	local paths = nil
	if not debug then paths = os:getEnvironment("DEPLOY_SHARED_PATH_RELEASE"):split("\n") else paths = os:getEnvironment("DEPLOY_SHARED_PATH_DEBUG"):split("\n") end

	-- Find files to deploy; qualitfy through paths.
	local files = os:getEnvironment("DEPLOY_SHARED"):split("\n")
	for _, p in ipairs(paths) do
		local deployFiles = ""
		for _, f in ipairs(files) do
			local qf = Path(p):concat(Path(f))
			if FileSystem.getInstance():exist(qf) then
				deployFiles = deployFiles .. " " .. f
			end
		end
		if deployFiles ~= "" then
			run:pushd(p)
			run:execute(tools.remote .. " deploy $(DEPLOY_TARGET_HOST) -t=\"$(DEPLOY_PROJECT_NAME)\" " .. deployFiles) -- , nil)
			run:popd()
			if run:exitCode() ~= 0 then return run:exitCode() end
		end
	end

	-- Clean some unwanted files.
	run:rm("*.ico")
	return 0
end


function deploy(args)
	-- Deploy application configuration to target.
	stdout:printLn("Deploying resources to target host...")
	run:execute(tools.remote .. " deploy $(DEPLOY_TARGET_HOST) -t=\"$(DEPLOY_PROJECT_NAME)\" Application.config", nil)
	if run:exitCode() ~= 0 then return run:exitCode() end

	-- Continue with either statically linked product or as a bunch of dynamic libraries.
	local staticLink = (os:getEnvironment("DEPLOY_STATIC_LINK") ~= "")
	if staticLink then
		return deployStatic(args)
	else
		return deployShared(args)
	end
end


function launch(args)
	stdout:printLn("Launching Win32...")
	local executable = os:getEnvironment("DEPLOY_EXECUTABLE")
	return run:execute(tools.remote .. " launch $(DEPLOY_TARGET_HOST) -t=\"$(DEPLOY_PROJECT_NAME)\" " .. executable .. " \\-s Application.config", nil)
end


local function migrateStatic(args)
	-- Link our product.
	local r = linkStaticProduct()
	if r ~= 0 then return r end

	-- Copy binaries into "bin".
	run:mkdir("bin32")
	run:replace("$(DEPLOY_EXECUTABLE).exe", "bin32/$(DEPLOY_EXECUTABLE).exe")

	-- Get shared paths.
	local paths = nil
	if not debug then paths = os:getEnvironment("DEPLOY_STATIC_PATH_RELEASE"):split("\n") else paths = os:getEnvironment("DEPLOY_STATIC_PATH_DEBUG"):split("\n") end

	-- Find files to deploy; qualitfy through paths.
	local files = os:getEnvironment("DEPLOY_STATIC"):split("\n")
	for _, p in ipairs(paths) do
		for _, f in ipairs(files) do
			if f ~= "" and not f:endswith(".lib") then
				local qf = Path(p):concat(Path(f))
				if FileSystem.getInstance():exist(qf) then
					run:replace(qf:getPathName(), "bin32/" .. f)
				end
			end
		end
	end

	return 0
end


local function migrateShared(args)
	local debug = (os:getEnvironment("DEPLOY_DEBUG") ~= "")

	-- Create icon resource.
	if not createIcon()	then
		stderr:printLn("Unable to create product icon.")
		return 1
	end

	run:mkdir("bin32")

	-- Get shared paths.
	local paths = nil
	if not debug then paths = os:getEnvironment("DEPLOY_SHARED_PATH_RELEASE"):split("\n") else paths = os:getEnvironment("DEPLOY_SHARED_PATH_DEBUG"):split("\n") end

	-- Find files to deploy; qualitfy through paths.
	local files = os:getEnvironment("DEPLOY_SHARED"):split("\n")
	for _, p in ipairs(paths) do
		for _, f in ipairs(files) do
			local qf = Path(p):concat(Path(f))
			if FileSystem.getInstance():exist(qf) then
				if not run:replace(qf:getPathName(), "bin32/" .. f) then
					stderr:printLn("Unable to copy file \"" .. f .. "\" to binary folder")
					return 1
				end
			end
		end
	end

	-- Clean some unwanted files.
	run:rm("*.ico")
	return 0
end


function migrate(args)
	stdout:printLn("Migrating Win32...")

	-- Build content database.
	run:execute(tools.migrate .. " -p -s=Migrate")
	if run:exitCode() ~= 0 then return run:exitCode() end

	-- Continue with either statically linked product or as a bunch of dynamic libraries.
	local staticLink = (os:getEnvironment("DEPLOY_STATIC_LINK") ~= "")
	if staticLink then
		return migrateStatic(args)
	else
		return migrateShared(args)
	end
end


function main(args)
	local action = args:get(0)
	if action == "build" then
		return build(args)
	elseif action == "deploy" then
		return deploy(args)
	elseif action == "launch" then
		return launch(args)
	elseif action == "migrate" then
		return migrate(args)
	end
	return 1
end
